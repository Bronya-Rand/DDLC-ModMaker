# Set the name of the workflow here
name: DDMMaker Builder

# Specify when to run this workflow
on:

  # We want this to run on every push
  push:
    branches:
      - '*'

  # We also want it to run when we publish a release on GitHub
  release:
    types: [published]

# Write the jobs and its steps
# This is where things get interesting.
jobs:
  build:
    name: Setting up SDK and OS
    runs-on: ubuntu-latest
    strategy:
      matrix:
        rnpy_versions:
          - '7.3.5'
          - '6.99.12.4'
    # Here's where we starting telling it how to run the workflow.
    steps:

      # First we clone the repo
      - name: Clone the repo
        uses: actions/checkout@v1
        with:
          fetch-depth: 50

          # We need this since sample_mod is actually a Git submodule.
          # This may not apply to you if your mod is in the repo itself.
          submodules: true
      # Finally, let's build the project.
      - name: Build Launcher
        uses: ProjectAliceDev/renpy-build-action@v1.1.1
        # This ID is needed for the release step.
        id: buildseq
        with:
          sdk-version: ${{ matrix.rnpy_versions }}
          project-dir: launcher
        env:
          SDL_AUDIODRIVER: dummy
          SDL_VIDEODRIVER: dummy
      - name: Publish artifact to GitHub Actions
        uses: actions/upload-artifact@v1
        with:
          name: ${{ steps.buildseq.outputs.dir }}
          path: ${{ format('{0}/{1}-sdk.zip', steps.buildseq.outputs.dir, steps.buildseq.outputs.version) }}
      - name: Upload files to release
        uses: skx/github-action-publish-binaries@master
        if: github.event.release # Runs ONLY when it's a published release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          # We use the outputs here to tell it where exactly the file is.
          args: ${{ format('{0}/{1}-sdk.zip', steps.buildseq.outputs.dir, steps.buildseq.outputs.version) }}
